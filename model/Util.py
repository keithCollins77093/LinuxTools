#   Project:        LinuxTools
#                   Imported from:  File Volume Indexer
#                       on April 3, 2022.
#   Author:         George Keith Watson
#   Date Started:   July 12, 2021
#   Copyright:      (c) Copyright 2021, 2022 George Keith Watson
#   Module:         model/Util.py
#   Purpose:        Base utilities which even Logging and Configuration are dependent on.
#                   Solves circular dependencies between these.
#   Development:
#       2021-07-31:     DBMetaData
#           Depending on the particular database which is queried for its meta data, the tables will
#           have particular content with particular structure.  The types developed or conceived
#           so far include:
#               Application Logs,
#                   Fields: autogenerated key row index, timestamp, message
#               User archived linux command output index,
#                   {"command": "dpkg",
#                   "args": ["-l"],
#                   "timeStamp": "2021-07-28 20:04:01.812314",
#                   "project": null,
#                   "analysis": null,
#                   "workflow": null,
#                   "notes": "",
#                   "fileName": "2021-07-28 20:04:01.812314 dpkg ('-l',).cmd_out"}
#               Configuration,
#                   Various formats appropriate to the subject matter
#               System and application log storage
#                   Fields: autogenerated key row index, message
#               Tokenized and field mapped system and application log storage
#                   Fields: autogenerated key row index, message
#               The parsed tabular output of various Linux commands run at particular times
#                   Various formats appropriate to the subject matter
#       2021-08-04:
#           I just included a DBMetaData type attribute while attempting to pickle an object using
#           copy.deepcopy and the Python run-time errored out with a message saying that I can't
#           pickle an SQLite connection type attribute.  Although I close the connection at the end of
#           constructing the DBMetaData object, the self.connection attribute remains assigned.
#           I fixed this by assigning None to self.connection at the end of the DBMetaData constructor.
#           LESSON:
#               For better security, always assign None to any SQLite connection variable when the database
#               is references is closed.
#

import sqlite3, os, sys, subprocess, json, signal
import platform
from datetime import datetime
from functools import partial
from signal import Signals
from copy import deepcopy
from collections import OrderedDict
from enum import Enum

#   Installation and Distribution:
#       INSTALLATION_FOLDER needs to have the correct value both when the source *.tar.gz file is
#       extracted and when the *.whl file is installed.
#       Solution:
#           1)  Detect first start  (Exception in first installation folder specific file access?)
#           2)  Use start folder or
#           2.5)    Ask user where they want the source folders and run environment installed.
#


if platform.system() == 'Windows':
    USER_HOME   = 'C:\\Users\\user'
    INSTALLATION_FOLDER     = 'C:\\Users\\user\\PycharmProjects\\LinuxLogForensics'
    VOLUMEINDEXER_FOLDER            = USER_HOME + '\\PycharmProjects\\VolumeIndexer'
    PROJECT_FOLDER                  = USER_HOME + '\\PycharmProjects\\LinuxLogForensics'
    TEMP_DATA_FOLDER                    = 'data\\temp'
    CONSOLE_OUT_TEXT_FOLDER             = 'consoleOutput\\text'
    CONSOLE_OUT_DB_FOLDER               = 'consoleOutput\\database'
    CONSOLE_OUT_JSON_FOLDER             = 'consoleOutput\\json'
    RAM_DISK_MOUNT_POINT                = '\\appCache\\'
    BASE_LOG_FOLDER                     = 'C:\\var\\log'
else:
    if 'HOME' in os.environ:
        USER_HOME =  os.environ['HOME']
    else:
        USER_HOME = '~'
    INSTALLATION_FOLDER             = USER_HOME + '/PycharmProjects/LinuxLogForensics'
    COMMON_DATA_FOLDER              = USER_HOME + '/PycharmProjects/CommonData'
    USER_CACHE_FOLDER               = INSTALLATION_FOLDER + "/userData/cache"
    VOLUMEINDEXER_FOLDER            = USER_HOME + '/PycharmProjects/VolumeIndexer'
    PROJECT_FOLDER                  = USER_HOME + '/PycharmProjects/LinuxLogForensics'
    OLD_PROJECT_FOLDER              = USER_HOME + '/PycharmProjects/LinuxLogReader'
    BASE_LOG_FOLDER                 = '/var/log'
    TEMP_DATA_FOLDER                    = 'data/temp'
    CONSOLE_OUT_TEXT_FOLDER             = 'consoleOutput/text'
    CONSOLE_OUT_DB_FOLDER               = 'consoleOutput/database'
    CONSOLE_OUT_JSON_FOLDER             = 'consoleOutput/json'
    RAM_DISK_MOUNT_POINT                = '/appCache/'

    BACKUP_DB_FOLDER                = INSTALLATION_FOLDER + '/metaData'

LOGGING_FOLDER                  = 'logs'
ARCHIVE_FOLDER                  = 'archive'
LOG_DB_FILE_NAME                = 'Logging.db'
CONFIG_DB_FILE_NAME             = 'Configuration.db'
INDEX_DB_FILE_NAME              = 'UserArchives.db'
DATABASE_INDEX_FILE             = 'db_index.txt'

BACKUP_DB_FILE                  = 'backup.db'
ARCHIVE_DB_FILE                 = 'archive.db'
SEARCH_DB_FILE                  = 'search.db'

APP_DATA_FOLDER                     = 'data'
USER_DATA_FOLDER                    = 'userData'
SAVED_CONSOLE_OUT_FOLDER            = 'consoleOutput'

USER_LOG_ARCHIVES_FOLDER            = 'logArchives'

USER_CONSOLE_OUT_DB                 = 'ConsoleOutput.db'

DOCUMENTATION_FOLDER            = 'Documentation'
MAN_PAGES_FOLDER                = 'man'
SUDO_HELP_FILE                  = 'sudo.help.txt'
SUDO_MAN_FILE                  = 'sudo.man.txt'

INDEX_FILE_FOLDER           = 'index'
INDEXED_DB_FOLDER           = 'db'
INDEXED_TEXT_FOLDER         = 'text'

APPLICATION_TEST_DATA       = 'testData'
MS_DOCX_SAMPLES             = 'docx'

APP_STATS_FOLDER            = 'appStats'


class Cursors(Enum):
    Hand_1      = 'hand1'
    Hand_2      = 'hand2'
    Arrow       = 'arrow'
    Circle      = 'circle'
    Clock       = 'clock'
    Cross       = 'cross'
    DotBox      = 'dotbox'
    Exchange    = 'exchange'
    Fluer       = 'fleur'
    Heart       = 'heart'
    Man         = "man"
    Mouse       = 'mouse'
    Pirate      = 'pirate'
    Plus        = 'plus'
    Shuttle     = "shuttle"
    Sizing      = 'sizing'
    Spider      = 'spider'
    Spraycan    = 'spraycan'
    Star        = 'star'
    Target      = 'target'
    Tcross      = 'tcross'
    Trek        = 'trek'
    Watch       = 'watch'

    def __str__(self):
        return self.value


class JsonIndex:
    """
    Whenever a class or category of files will accumulate, like saved console output or log time range archives
    an index on the disk is required to find the files based on either their full path or an identifier that
    the user provided for the particular item.
    Allowed types depend on application features and are hard coded:
        log file archive
        log archive (.gz in debian) archive
        log type time range archive
        log collection time range archive
        same as above 4 for application specific logs
        console output for particular parameterized Linux command
            the identifying key fields for this are command name, argument list, time stamp.
            the user should be allowed to add a name to the file.
            the name should be unique but would also be useful in categorizing console output, i.e. grouping into
                particular studies or analytical work-flows.
    The index file's full file path name will be the key in all of these index types.
    All will be file build time timestamped except console output, which will be command run time timestamped.
    """
    TYPES   = ('log file archive', 'log archive archive', 'log type time range archive',
               'log collection time range archive',
               'app log file archive', 'app log archive archive', 'app log type time range archive',
               'app log collection time range archive',
               'console output archive')

    def __init__(self, **keyWordArguments):
        """
        Since each index corresponds to a particular json file and only the collection contents are immutable,
        this class can be immutable for security.
        :param keyWordArguments:    Must contain: archiveFileName, archiveType,
                                    If archiveFileName does not exist it is created.

        """
        print('JsonIndex constructor:\t' + str(keyWordArguments))
        self.checkArguments(**keyWordArguments)
        self.indexFileName    = keyWordArguments['indexFileName']
        self.archiveType        = keyWordArguments['archiveType']
        if self.archiveType == 'console output archive':
            self.pathName = INSTALLATION_FOLDER + '/' + USER_DATA_FOLDER + '/' + CONSOLE_OUT_TEXT_FOLDER
        elif self.archiveType in ('log file archive', 'log archive archive', 'log type time range archive',
                               'log collection time range archive', 'app log file archive',
                                'app log archive archive', 'app log type time range archive',
                               'app log collection time range archive'):
            self.pathName = INSTALLATION_FOLDER + '/' + USER_DATA_FOLDER + '/' + USER_LOG_ARCHIVES_FOLDER
        if not os.path.isdir(self.pathName):
            raise Exception('JsonIndex constructor - folder with indexed files does not exist:    ' + self.pathName)
        if not os.path.isfile(self.pathName + '/' + keyWordArguments['indexFileName']):
            indexFile   = open(self.pathName + '/' + keyWordArguments['indexFileName'], 'w')
            indexFile.close()
        self.index = {}

    def addEntry(self, archiveType: str, indexFileName: str, entry: dict):
        self.checkArguments(**{'archiveType': archiveType, 'indexFileName': indexFileName})
        print('JsonIndex.addEntry:\t' + str(entry))
        if archiveType == 'console output archive':
            #   "command": str
            #   'args': typle of str
            #   'timeStamp': datetime
            if "command" not in entry or 'args' not in entry or 'timeStamp' not in entry:
                raise Exception("JsonIndex.addEntry - missing key field(s)")
            if not isinstance( entry["command"], str ):
                raise Exception("JsonIndex.addEntry - invalid command argument:    " + str(entry["command"]))
            if not isinstance( entry['args'], tuple ):
                raise Exception("JsonIndex.addEntry - invalid args argument:    " + str(entry["args"]))
            else:
                for arg in entry['args']:
                    if not isinstance(arg, str):
                        raise Exception("JsonIndex.addEntry - invalid arg argument:    " + str(arg))
            if not isinstance( entry["timeStamp"], datetime ) and not (isinstance(entry["timeStamp"], str) and
                     isinstance(datetime.strptime(entry["timeStamp"], '%Y-%m-%d %H:%M:%S.%f'), datetime)):
                raise Exception("JsonIndex.addEntry - invalid timeStamp argument:    " + str(entry["timeStamp"]))
            if isinstance(entry['timeStamp'], datetime):
                entry['timeStamp'] = str(entry['timeStamp'])

            text = json.dumps(entry)
            print('Type of json.dumps()' + str(type(text)))
            print('\t' + text)
            #   json.dump(file, )
            indexFilePath = INSTALLATION_FOLDER + '/' + USER_DATA_FOLDER + '/' + CONSOLE_OUT_TEXT_FOLDER + '/' + \
                            indexFileName
            file = open(indexFilePath, 'a')
            file.write(text + '\n')
            file.close()

    def checkArguments(self, **keyWordArguments):
        print('checkArguments:\t' + str(keyWordArguments))
        if 'indexFileName' not in keyWordArguments:
            raise Exception('JsonIndex constructor - missing indexFileName argument')
        if 'archiveType' not in keyWordArguments:
            raise Exception('JsonIndex constructor - missing archiveType argument')
        if keyWordArguments['indexFileName'] is None or not isinstance(keyWordArguments['indexFileName'], str):
            raise Exception('JsonIndex constructor - invalid indexFileName argument:    ' + str(keyWordArguments['indexFileName']))
        if keyWordArguments['archiveType'] is None or keyWordArguments['archiveType'] not in JsonIndex.TYPES:
            raise Exception('JsonIndex constructor - invalid archiveType argument:    ' + str(keyWordArguments['archiveType']))



    def __setattr__(self, key, value):
        if key in self.__dict__:
            return False
        self.__dict__[key] = value
        return True


class TimeStamp:

    def __init__(self, **keyWordArguments):
        """
        Not argument filtering required.
        It is appropriate that the application crash if invalid data is passed to the TimeStamp constructor.
        Including argument filtering code will expose the internal structure of the object.
        :param keyWordArguments:
        """
        if 'datetime' in keyWordArguments:
            timeStamp = keyWordArguments['datetime']
            self.year       = timeStamp.year
            self.month      = timeStamp.month
            self.day        = timeStamp.day
            self.hour       = timeStamp.hour
            self.minute     = timeStamp.minute
            self.second     = timeStamp.second
            self.micro      = timeStamp.microsecond
        else:
            for key, value in keyWordArguments.items():
                self.__dict__[key] = value

    def __setattr__(self, key, value):
        if not key in self.__dict__:
            self.__dict__[key] = value
        else:
            raise Exception('TimeStamp:    Attempt to set immutable attribute')

    def parse(self):
        """
        Parses the timeStamp string format constructed by this class' __str__() method into its separate fields.
        example: "2021/07/22 16:22:06.303286"
        :return: a map with the different time fields in it.
        """
        (date, time) = self.__str__().split(' ')
        (year, month, day)  = date.split('/')
        (hour, minute, second)   = time.split(':')
        (second, micro)     = second.split('.')
        return TimeStamp(year=int(year), month=int(month), day=int(day), hour=int(hour), minute=int(minute),
                         second=int(second), micro=int(micro))

    def __str__(self):
        return "{year:4d}/{month:2d}/{day:2d}".format(year=self.year, month=self.month, day=self.day).replace(' ', '0')\
               + ' ' + "{hour:2d}:{minute:2d}:{second:2d}.{micro:6d}".format(hour=self.hour, minute=self.minute,
                second=self.second, micro=self.micro).replace(' ', '0')


class LinuxUtilities:

    registry = {}

    def __init__(self):
        constructionTime = str(datetime.now())
        LinuxUtilities.registry[constructionTime] = self
        self.runLog     = OrderedDict()
        self.runTimes   = []

    def runLinuxTool(self, commandList: tuple):
        outputText = ''
        if commandList is None or not isinstance(commandList, tuple):
            raise Exception('runLinuxCommand - invalid command list argument:\t' + str(commandList))
        try:
            runTime = datetime.now()
            self.runTimes.append(runTime)
            outputText = ''
            sub     = subprocess.Popen(commandList, stdout=subprocess.PIPE, stderr=subprocess.STDOUT )
            output, error_message = sub.communicate()
            outputText  = output.decode('utf-8')
            self.runLog[runTime] = {
                'commandList': deepcopy(commandList),
                'output': deepcopy(output),
                'error_message': deepcopy(error_message),
                'outputText': deepcopy(outputText)
            }
        except Exception:
            outputText = ''
            for line in sys.exc_info():
                outputText += str(line) + '\n'
        finally:
            return outputText

    def getRunLog(self):
        return self.runLog

    def getMostRecent(self):
        if len(self.runTimes) > 0:
            return self.runLog[self.runTimes[len(self.runTimes)-1]]
        return None


class MemoryMonitor:

    def __init__(self):
        self.index = []
        self.monitorLog = {}

    def poll(self):
        memoryStats = {}
        try:
            sub = subprocess.Popen( ["free", "--mega"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            lastCommandRunTime = str(datetime.now())
            #   print("Sortable Time Stamp:\t" + lastCommandRunTime)
            output, error_message = sub.communicate()
            outputLines = output.decode('utf-8').split('\n')
            fieldNames = outputLines[0].split()
            fieldValues = outputLines[1].split()
            del (fieldValues[0])
            idx = 0
            while idx < len(fieldNames):
                memoryStats[fieldNames[idx]] = fieldValues[idx]
                idx += 1
            #   print('memoryStats (MB):\t' + str(memoryStats))
            self.index.append(lastCommandRunTime)
            self.monitorLog[lastCommandRunTime] = memoryStats
        except Exception:
            outputText = ''
            for line in sys.exc_info():
                outputText += str(line) + '\n'
            print(outputText, file=sys.stderr)

        return memoryStats

    def getMostRecent(self):
        if len(self.index) > 0:
            return self.monitorLog[self.index[len(self.index)-1]]
        return None

    def getMonitorLog(self):
        return self.monitorLog

    def __setattr__(self, key, value):
        if key not in self.__dict__:
            self.__dict__[key] = value


class SignalMonitor:

    registry = {}

    def __init__(self, name):
        print('SignalMonitor constructor - RUNNING')
        #   print('Valid Signals:\t' + str(signal.valid_signals()))
        SignalMonitor.registry[name] = self
        self.signalLog = {}
        self.logIndex = ()
        self.signalListeners = {}

        signalList = list(signal.valid_signals())
        idx = 0
        deleteList = []
        while idx < len(signalList):
            if type(signalList[idx]) != Signals:
                deleteList.append(idx)
            idx += 1
        #   print('deleteList:\t' + str(deleteList))
        idx = len(deleteList) - 1
        while idx >= 0:
            deleteList[idx]
            del(signalList[deleteList[idx]])
            idx -= 1
        #   print('signalList:\t' + str(signalList))

        for member in signalList:
            #   print('Type of set member:\t' + str(type(member)))
            #   print('Set member:\t' + str(member))
            if member not in (signal.SIGKILL, Signals.SIGSTOP):
                signal.signal( member, partial(self.signalHandler, member))
                self.signalListeners[member] = ()

    def signalHandler(self, signalName, *args):
        print('SignalMonitor.signalHandle():\t' + str(signalName))
        #   print("\t*args:\t" + str(args))
        timeStamp = str(datetime.now())
        self.signalLogger(signalName, timeStamp)
        for callback in self.signalListeners[signalName]:
            callback({"signal": signalName, 'timeStamp': str(datetime.now())})

    def signalLogger(self, signalName, timeStamo: str):
        print('SignalMonitor.signalLogger():\t' + str(signalName) + '\tat\t' + timeStamo)
        #   Make sure index is immutable:
        self.logIndex = list(self.logIndex)
        self.logIndex.append(timeStamo)
        self.logIndex = tuple(self.logIndex)
        self.signalLog[timeStamo] = signalName

    def registerListener(self, signalId, callback):
        if signalId not in signal.valid_signals():
            raise Exception("SignalMonitor.registerListener - invalid signalId argument:    " + str(signalId))
        if not callable(callback):
            raise Exception("SignalMonitor.registerListener - invalid callback argument:    " + str(callback))
        self.signalListeners[signalId] = list(self.signalListeners[signalId])
        self.signalListeners[signalId].append(callback)
        self.signalListeners[signalId] = tuple(self.signalListeners[signalId])


class ListFileRow:

    def __init__(self, fileName: str):
        """
        Make a tuple of the values in an ls -l listing for a particular file and assign immutable attributes
        recording the same.
        :param fileName:     Full path from root to file as a string.
        """
        if fileName is None or not isinstance(fileName, str):
            raise Exception("ListFileRow constructor - invalid fileName argument:    " + str(fileName))
        if os.path.isfile(fileName):
            print('ListFileRow:\t' + fileName)
            self.fileName   = fileName
            argv = ('ls', '-l', fileName)
            sub = subprocess.Popen(argv,  stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            output, error_message = sub.communicate()
            print(output.decode('utf-8'))
            self.attributeList  = tuple(output.decode('utf-8').split())
            print('self.attributeList:\t' + str(self.attributeList))
            self.permissions    = self.attributeList[0]
            self.dirOrLinkCount = self.attributeList[1]
            self.owner          = self.attributeList[2]
            self.group          = self.attributeList[3]
            self.size           = self.attributeList[4]
            self.month          = self.attributeList[5]
            self.day            = self.attributeList[6]
            self.timeYear       = self.attributeList[7]
            self.name           = self.attributeList[8]

    def __str__(self):
        text = '\nAttribute of:\t' + self.fileName
        for key, value in self.__dict__.items():
            text    += "\n\t" + key + ":\t" + str(value)
        return text

    def __setattr__(self, key, value):
        if not key in self.__dict__:
            self.__dict__[key] = value


class LinuxApplication:
    """
    Try:
        info -d cvs
    """

    def __init__(self):
        pass


class InstalledApplications:

    def __init__(self):
        self.AppFiles = OrderedDict()
        self.appNames = []
        self.linuxAppPath   = '/usr/share/'
        linuxUtilities = LinuxUtilities()
        linuxUtilities.runLinuxTool(('ls', '-l', '/usr/share/applications'))
        fileList    = linuxUtilities.getMostRecent()['outputText']
        outputLines = fileList.split('\n')
        for line in outputLines:
            parts = line.split()
            if len(parts) > 2:
                appName     = parts[len(parts)-1].split('.')[0]
                self.appNames.append(appName)
                self.AppFiles[appName] = parts

    def listNames(self):
        print('\nInstalledApplications:')
        for key, value in self.AppFiles.items():
            print("\t" + key)

    def getAppFiles(self):
        return self.AppFiles

    def getLinuxAppPath(self):
        return self.linuxAppPath

    def getAppNameList(self):
        return self.appNames

    def getAppFileLine(self, appName: str):
        return self.AppFiles[appName]

    def getAppFilePath(self, appName):
        return self.linuxAppPath + self.AppFiles[appName][len(self.AppFiles[appName])-1]


def pathFromList(fileNameList: tuple):
    if fileNameList is None or not isinstance(fileNameList, tuple) or len(fileNameList) < 1:
        raise Exception('Util.pathFromList - invalid fileNameList argument:    ' + str(fileNameList))
    fileNameList = list(fileNameList)
    pathName = fileNameList[0]
    if platform.system() == 'Windows':
        pathParts = []
        for pathPart in fileNameList:
            pathParts += list(listFromPathString(pathPart))
        pathName = pathParts[0]
        pathParts.pop(0)
        return os.path.join(pathName, *pathParts)
    idx = 1
    while idx < len(fileNameList):
        pathName += '/' + fileNameList[idx]
        idx += 1
    return pathName


def listFromPathString(pathName: str):
    """
    Assumes Linux formatted path name, i.e. no 'file::' or other protocol prepended and with '/' for separation.
    This will be modified as needed to handle MS Windows format and URI/URL strings.
    :param pathName:
    :return:
    """
    list = pathName.split('/')
    if len( list[0] ) == 0:
        del(list[0])
    return tuple(list)


def alarmSignalHandler(message: dict, *args):
    print('alarmSignalHandler - message:\t' + str(message))


if __name__ == '__main__':
    print('Util.py RUNNING')

    """
    #   dBMetaData      = DBMetaData(LOG_DB_FILE_NAME)

    signalMonitor = SignalMonitor('My First')
    signalMonitor.registerListener(signal.SIGALRM, alarmSignalHandler)
    signal.raise_signal(signal.SIGALRM)

    #   signal.signal(signal.SIGKILL, alarmSignalHandler)
    #   signal.raise_signal(signal.SIGKILL)

    signal.signal(signal.SIGALRM, partial(alarmSignalHandler, {}))
    signal.raise_signal(signal.SIGALRM)
    """

    #   filePath = pathFromList((INSTALLATION_FOLDER, 'packageAudit.sh'))
    #   print("filePath:\t" + filePath)
    listFileRow     = ListFileRow(pathFromList((INSTALLATION_FOLDER, 'packageAudit.sh')))
    #   print(str(listFileRow))

    #   print('SignalMonitor.registry:\t' + str(SignalMonitor.registry))

    memoryMonitor   = MemoryMonitor()
    memoryMonitor.poll()
    print(str(memoryMonitor.getMonitorLog()))
    print(str(memoryMonitor.getMostRecent()))


    linuxUtilities  = LinuxUtilities()
    """
    linuxUtilities.runLinuxTool(('ls', '-l') )
    print("\n" + str(linuxUtilities.getMostRecent()))
    print()
    for name, value in linuxUtilities.getMostRecent().items():
        print("\t" + name + ":\t" + str(value))
    """
    linuxUtilities.runLinuxTool(('ls', '-l', '/usr/share/applications'))
    print()
    for name, value in linuxUtilities.getMostRecent().items():
        print("\t" + name + ":\t" + str(value))


    installedApplications   = InstalledApplications()
    #   installedApplications.listNames()
    print(installedApplications.getAppFilePath('yelp'))